<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html lang="en"><head>
  <title>Neil Fraser: Writing: Fuzzy Patch</title>
  <link href="Neil%20Fraser%20%20Writing%20%20Fuzzy%20Patch_files/homepage.css" rel="stylesheet" type="text/css">
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <link rel="icon" href="https://neil.fraser.name/favicon.ico" type="image/x-ico">
  <link rel="SHORTCUT ICON" href="https://neil.fraser.name/favicon.ico">
  <meta name="keywords" content="Neil Fraser">
  <link rel="start" href="https://neil.fraser.name/" title="Neil Fraser's Homepage">
  <link rel="up" href="https://neil.fraser.name/writing/" title="Neil's Writing">
</head>

<body>
<!-- JavaScript code highlighting courtesy of http://www.howtocreate.co.uk/tutorials/jsexamples/syntax/ -->
<!-- Python code highlighting courtesy of http://www.sweetapp.com/cgi-bin/cgi-styler-form.py -->
<style>
span.comment, span.p_commentblock, span.p_commentline {color: green; font-weight: normal;}
span.oper, span.p_operator, span.p_word {color: mediumblue; font-weight: normal;}
span.var, span.p_identifier {color: #404040; font-weight: normal;}
span.func, span.p_defname {color: darkred; font-weight: normal;}
span.string, span.p_string, span.p_stringeol, span.p_triple, span.p_tripledouble {color: #a00000; font-weight: normal;}
span.num, span.p_number {color: #b0800a; font-weight: bold;}
span.reg {color: #8d7f07; font-weight: normal;}

ins, span.ins {background-color: rgb(230, 255, 230)}
del, span.del {background-color: rgb(255, 230, 230)}
span.one {color: red}
</style>

<script>
var steps = 10;

function show(name, section) {
  document.getElementById(name).style.display="none";
  document.getElementById(name+section).style.display="block";
}
function hide(name, section) {
  var oldTop = document.body.scrollTop || window.pageYOffset;
  var newTop = document.getElementById(name+section).offsetTop - 100;
  if (newTop && oldTop && oldTop > newTop + 100) {
    scrollStep(oldTop, (newTop - oldTop) / steps, steps, name, section);
  } else {
    do_hide(name, section);
  }
}
function do_hide(name, section) {
  document.getElementById(name).style.display="block";
  document.getElementById(name+section).style.display="none";
}
function scrollStep(y, dy, n, name, section) {
  if (n <= 1) {
    y += dy/2; // Slight deceleration.
  } else {
    y += dy;
  }
  window.scrollTo(0, y);
  if (n > 0) {
    window.setTimeout("scrollStep("+y+", "+dy+", "+(n-1)+", '"+name+"', '"+section+"')", 500/steps);
  } else {
    window.setTimeout("do_hide('"+name+"', '"+section+"')", 250);
  }
}
</script>

<h1>Fuzzy Patch</h1>
<p><i>by Neil Fraser, May 2006</i></p>

<p><i>Patch</i> is the process of modifying a document based on a set of edits created by a <a href="https://neil.fraser.name/writing/diff/">difference algorithm</a>.  A typical use case would be a developer who creates a new version of a document, uses <i>diff</i>
 to create a set of edits, then transmits those edits to a customer, who
 then applies them to their version of the document, thus recreating the
 new version.</p>

<img src="Neil%20Fraser%20%20Writing%20%20Fuzzy%20Patch_files/diff-patch.gif" alt="[Diagram showing the relationship between diff and patch]" width="400" height="158">

<p>A strict patch program is a trivial piece of software.  It would just
 execute a scripted set of insertions and deletions on one version of 
the document to produce the other version.  Assuming that both copies of
 the base document (in the above case labeled 'V1') are identical, then 
both copies of the second document (in the above case labeled 'V2') will
 also be identical.  However, the program becomes more complicated when 
the two copies of the base document are not identical.  In these cases 
the patch program must do the best job it can in applying the edits to 
the correct locations.  This paper examines one method for building such
 a patch program.</p>

<h2>GNU patch</h2>

<p>The de facto standard for patch is <a href="http://www.gnu.org/software/patch/">GNU's implementation</a>.
  The following example shows how edits for GNU's patch are structured. 
 The first line contains line number information describing where the 
following edit should be performed.  The edit is preceded and followed 
by three lines of context.  The edit in this case involves the deletion 
of two lines and the insertion of three lines.</p>

<pre>@@ -382,8 +481,9 @@
       function maxbits(){
          // Compute the number of bits in the highest int available.
          // i: maxint; b: maxbits
<span class="del">-         var b=1;</span>
<span class="del">-         for(var i=2; (i+1)!=i; i*=2)</span>
<span class="ins">+         // No system will have less than 8 bits</span>
<span class="ins">+         var b=8;</span>
<span class="ins">+         for(var i=256; (i+1)!=i; i*=2)</span>
            b++;
          return b;
       }</pre>

<p>GNU's patch uses a fairly primitive matching system for inexact patches.  Its documentation states:</p>

<blockquote>
"[...] patch can detect when the line numbers mentioned in the patch are
 incorrect, and attempts to find the correct place to apply each hunk of
 the patch.  As a first guess, it takes the line number mentioned for 
the hunk, plus or minus any offset used in applying the previous hunk.  
If that is not the correct place, patch scans both forwards and 
backwards for a set of lines matching the context given in the hunk.  
First patch looks for a place where all lines of the context match.  If 
no such place is found, [...] then another scan takes place ignoring the
 first and last line of context.  If  that fails, [...] the first two 
and last two lines of context are ignored, and another scan is made."
</blockquote>

<p>This simple strategy is relatively fragile.  Minor changes between 
the two base documents can result in failure.  In the above example if 
the function name had been changed from "maxbits" to "max_bits" the 
patch would have failed to match on the first pass, but would have 
matched on the second pass (once the first line of the prefix context 
was ignored).  However, if the "b++;" had been changed to "b=b+1;", the 
patch would fail, despite the fact that all the other context lines 
match.</p>

<p>This simple strategy is also unrestricted by location.  If there are 
two similar pieces of text, and the correct piece has been changed (or 
removed) causing it to fail to match, GNU's patch will happily target 
the other piece even if it is at the opposite end of the file.</p>

<p>A more sophisticated approach would increase the number of successful
 matches (thereby avoiding unnecessary human intervention) and decrease 
the number of failed matches (thereby avoiding errors).  A more 
sophisticated approach would be character-based instead of line-based 
(thereby allowing multiple edits to be merged onto the same line).</p>

<h2>Context Size</h2>

<p>GNU's patch expects three lines of context preceding and following 
each edit block.  If this is insufficient context, the edit might be 
applied to the wrong place.  If there is too much context, edits may 
fail due to unrelated changes which lie considerable distance from the 
target spot.  Excessive context also increases the processing time for 
locating the best match; depending on the matching algorithm, 
potentially exponentially.  Achieving the right balance is a challenge 
due to the nature of different texts.</p>

<img src="Neil%20Fraser%20%20Writing%20%20Fuzzy%20Patch_files/pattern-pp.png" alt="[Graph of repeated patterns in English Text]" width="517" height="403">

<p>English text follows a very clean and sharp exponential decline in 
matches as the pattern length increases.  From the above analysis of 
Jane Austin's <i>Pride and Prejudice</i>, a fifteen-character pattern has less than a 2% chance of occurring twice in the same chapter.</p>

<img src="Neil%20Fraser%20%20Writing%20%20Fuzzy%20Patch_files/pattern-linux.png" alt="[Graph of repeated patterns in the Linux Kernel]" width="517" height="403">

<p>By contrast, computer code contains far more repetitions.  From the 
above analysis of the Linux Kernel's source code, a fifteen-character 
pattern is likely to occur 250 times in the same file.  Interestingly, 
the overwhelming majority of these repetitions are not caused by code 
itself, but instead by decorative ASCII art.  In particular, horizontal 
lines formed from repeated characters intended to separate one code 
block from another.  The worst offender is the 1.7MB <tt>include/asm-ia64/sn/sn2/shub_mmr.h</tt> which includes 1644 identical copies of this line:</p>

<pre>/* ==================================================================== */</pre>

<fieldset><legend>Analysis Method</legend>

<p>Both of these analyses selected a random chunk of characters from 
across the entire work (with longer chapters or files more likely to be 
selected than shorter ones).  The originating chapter or file was then 
scanned for occurrences of the chunk, not counting the original 
location.  This was repeated one thousand times for each chunk size, and
 the results averaged.</p>

<div id="code1"><button onclick="show('code1', 'b')">Show Code</button></div>
<div id="code1b" style="display: none">
<pre><span class="p_commentline">#!/usr/bin/python</span><span>
</span><span class="p_commentline"># Scans a tarfile for frequency of repeated patterns.</span><span>
</span><span class="p_commentline"># Usage:  ./pattern.py filename</span><span>
</span><span class="p_commentline"># Expects 'filename.tar' to exist (used as an index) as well as a</span><span>
</span><span class="p_commentline"># directory 'filename/' which contains all the expanded files.</span><span>

</span><span class="p_word">import</span> <span class="p_identifier">os</span><span class="p_operator">,</span> <span class="p_identifier">sys</span><span class="p_operator">,</span> <span class="p_identifier">random</span><span>
</span><span class="p_word">from</span> <span class="p_identifier">stat</span> <span class="p_word">import</span> <span class="p_operator">*</span><span>

</span><span class="p_identifier">projectname</span> <span class="p_operator">=</span> <span class="p_identifier">sys</span><span class="p_operator">.</span><span class="p_identifier">argv</span><span class="p_operator">[</span><span class="p_number">1</span><span class="p_operator">]</span><span>
</span><span class="p_identifier">tarsize</span> <span class="p_operator">=</span> <span class="p_identifier">os</span><span class="p_operator">.</span><span class="p_identifier">stat</span><span class="p_operator">(</span><span class="p_identifier">projectname</span><span class="p_operator">+</span><span class="p_string">".tar"</span><span class="p_operator">)[</span><span class="p_identifier">ST_SIZE</span><span class="p_operator">]</span><span>
</span><span class="p_word">print</span> <span class="p_character">'Reading %s (%i bytes)'</span> <span class="p_operator">%</span> <span class="p_operator">(</span><span class="p_identifier">projectname</span><span class="p_operator">+</span><span class="p_string">".tar"</span><span class="p_operator">,</span> <span class="p_identifier">tarsize</span><span class="p_operator">)</span><span>
</span><span class="p_identifier">tarhandle</span> <span class="p_operator">=</span> <span class="p_identifier">file</span><span class="p_operator">(</span><span class="p_identifier">projectname</span><span class="p_operator">+</span><span class="p_string">".tar"</span><span class="p_operator">,</span> <span class="p_character">'r'</span><span class="p_operator">)</span><span>
</span><span class="p_identifier">tardata</span> <span class="p_operator">=</span> <span class="p_identifier">tarhandle</span><span class="p_operator">.</span><span class="p_identifier">read</span><span class="p_operator">()</span><span>
</span><span class="p_identifier">tarhandle</span><span class="p_operator">.</span><span class="p_identifier">close</span><span class="p_operator">()</span><span>

</span><span class="p_word">def</span> <span class="p_defname">getfilename</span><span class="p_operator">(</span><span class="p_identifier">tardata</span><span class="p_operator">):</span><span>
  </span><span class="p_commentline"># Jump to a random spot in the tar file.  Then backtrack to the filename.</span><span>
  </span><span class="p_word">while</span> <span class="p_number">1</span><span class="p_operator">:</span><span>
    </span><span class="p_identifier">position</span> <span class="p_operator">=</span> <span class="p_identifier">random</span><span class="p_operator">.</span><span class="p_identifier">randint</span><span class="p_operator">(</span><span class="p_number">0</span><span class="p_operator">,</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">tardata</span><span class="p_operator">)-</span><span class="p_number">1</span><span class="p_operator">)</span><span>
    </span><span class="p_identifier">char</span> <span class="p_operator">=</span> <span class="p_identifier">tardata</span><span class="p_operator">[</span><span class="p_identifier">position</span><span class="p_operator">]</span><span>
    </span><span class="p_word">if</span> <span class="p_operator">(</span><span class="p_identifier">char</span> <span class="p_operator">&lt;</span> <span class="p_character">' '</span> <span class="p_word">or</span> <span class="p_character">'~'</span> <span class="p_operator">&lt;</span> <span class="p_identifier">char</span><span class="p_operator">)</span> <span class="p_word">and</span> <span class="p_identifier">char</span> <span class="p_operator">!=</span> <span class="p_character">'\t'</span> <span class="p_word">and</span> <span class="p_identifier">char</span> <span class="p_operator">!=</span> <span class="p_character">'\n'</span> <span class="p_word">and</span> <span class="p_identifier">char</span> <span class="p_operator">!=</span> <span class="p_character">'\r'</span><span class="p_operator">:</span><span>
      </span><span class="p_word">pass</span> <span class="p_commentline"># Bad character</span><span>
    </span><span class="p_word">else</span><span class="p_operator">:</span><span>
      </span><span class="p_identifier">position</span> <span class="p_operator">=</span> <span class="p_identifier">tardata</span><span class="p_operator">.</span><span class="p_identifier">rfind</span><span class="p_operator">(</span><span class="p_identifier">projectname</span><span class="p_operator">+</span><span class="p_string">"/"</span><span class="p_operator">,</span> <span class="p_number">0</span><span class="p_operator">,</span> <span class="p_identifier">position</span><span class="p_operator">)</span><span>
      </span><span class="p_word">if</span> <span class="p_identifier">position</span> <span class="p_operator">!=</span> <span class="p_operator">-</span><span class="p_number">1</span><span class="p_operator">:</span><span>
        </span><span class="p_identifier">filename</span> <span class="p_operator">=</span> <span class="p_character">''</span><span>
        </span><span class="p_word">while</span> <span class="p_character">' '</span> <span class="p_operator">&lt;=</span> <span class="p_identifier">tardata</span><span class="p_operator">[</span><span class="p_identifier">position</span><span class="p_operator">]</span> <span class="p_word">and</span> <span class="p_identifier">tardata</span><span class="p_operator">[</span><span class="p_identifier">position</span><span class="p_operator">]</span> <span class="p_operator">&lt;=</span> <span class="p_character">'~'</span><span class="p_operator">:</span><span>
           </span><span class="p_identifier">filename</span> <span class="p_operator">=</span> <span class="p_identifier">filename</span> <span class="p_operator">+</span> <span class="p_identifier">tardata</span><span class="p_operator">[</span><span class="p_identifier">position</span><span class="p_operator">]</span><span>
           </span><span class="p_identifier">position</span> <span class="p_operator">=</span> <span class="p_identifier">position</span> <span class="p_operator">+</span> <span class="p_number">1</span><span>
        </span><span class="p_commentline"># Ignore directory definitions</span><span>
        </span><span class="p_word">if</span> <span class="p_identifier">filename</span><span class="p_operator">[</span><span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">filename</span><span class="p_operator">)-</span><span class="p_number">1</span><span class="p_operator">]</span> <span class="p_operator">!=</span> <span class="p_character">'/'</span><span class="p_operator">:</span><span>
          </span><span class="p_word">return</span> <span class="p_identifier">filename</span><span>

</span><span class="p_commentline"># Start with two-character chunks, and grow.</span><span>
</span><span class="p_word">print</span> <span class="p_string">"Size\tAverage    \tMax    \tFile"</span><span>
</span><span class="p_word">for</span> <span class="p_identifier">chunksize</span> <span class="p_word">in</span> <span class="p_identifier">range</span><span class="p_operator">(</span><span class="p_number">2</span><span class="p_operator">,</span> <span class="p_number">100</span><span class="p_operator">):</span><span>
  </span><span class="p_identifier">score</span> <span class="p_operator">=</span> <span class="p_number">0</span><span>
  </span><span class="p_identifier">verb</span> <span class="p_operator">=</span> <span class="p_character">''</span><span>
  </span><span class="p_identifier">maxscore</span> <span class="p_operator">=</span> <span class="p_number">0</span><span>
  </span><span class="p_identifier">minscore</span> <span class="p_operator">=</span> <span class="p_operator">-</span><span class="p_number">1</span><span>
  </span><span class="p_commentline"># Do the test 1000 times then take the average.</span><span>
  </span><span class="p_word">for</span> <span class="p_identifier">i</span> <span class="p_word">in</span> <span class="p_identifier">range</span><span class="p_operator">(</span><span class="p_number">1000</span><span class="p_operator">):</span><span>
    </span><span class="p_commentline"># Open a random file (weighted by size)</span><span>
    </span><span class="p_identifier">filename</span> <span class="p_operator">=</span> <span class="p_identifier">getfilename</span><span class="p_operator">(</span><span class="p_identifier">tardata</span><span class="p_operator">)</span><span>
    </span><span class="p_identifier">filehandle</span> <span class="p_operator">=</span> <span class="p_identifier">file</span><span class="p_operator">(</span><span class="p_identifier">filename</span><span class="p_operator">,</span> <span class="p_character">'r'</span><span class="p_operator">)</span><span>
    </span><span class="p_identifier">filedata</span> <span class="p_operator">=</span> <span class="p_identifier">filehandle</span><span class="p_operator">.</span><span class="p_identifier">read</span><span class="p_operator">()</span><span>
    </span><span class="p_identifier">filehandle</span><span class="p_operator">.</span><span class="p_identifier">close</span><span class="p_operator">()</span><span>

    </span><span class="p_word">if</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">filedata</span><span class="p_operator">)</span> <span class="p_operator">&gt;</span> <span class="p_identifier">chunksize</span><span class="p_operator">:</span><span>
      </span><span class="p_identifier">pointer</span> <span class="p_operator">=</span> <span class="p_identifier">random</span><span class="p_operator">.</span><span class="p_identifier">randint</span><span class="p_operator">(</span><span class="p_number">0</span><span class="p_operator">,</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">filedata</span><span class="p_operator">)-</span><span class="p_identifier">chunksize</span><span class="p_operator">-</span><span class="p_number">1</span><span class="p_operator">)</span><span>
      </span><span class="p_identifier">chunk</span> <span class="p_operator">=</span> <span class="p_identifier">filedata</span><span class="p_operator">[</span><span class="p_identifier">pointer</span><span class="p_operator">:</span><span class="p_identifier">pointer</span><span class="p_operator">+</span><span class="p_identifier">chunksize</span><span class="p_operator">]</span><span>
      </span><span class="p_identifier">hits</span> <span class="p_operator">=</span> <span class="p_operator">-</span><span class="p_number">1</span> <span class="p_commentline"># Don't count the seed</span><span>
      </span><span class="p_identifier">pointer</span> <span class="p_operator">=</span> <span class="p_number">0</span><span>
      </span><span class="p_commentline"># Find out how many other instances of chunk are present</span><span>
      </span><span class="p_word">while</span> <span class="p_identifier">pointer</span> <span class="p_operator">&lt;</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">filedata</span><span class="p_operator">):</span><span>
        </span><span class="p_identifier">pointer</span> <span class="p_operator">=</span> <span class="p_identifier">filedata</span><span class="p_operator">.</span><span class="p_identifier">find</span><span class="p_operator">(</span><span class="p_identifier">chunk</span><span class="p_operator">,</span> <span class="p_identifier">pointer</span><span class="p_operator">)</span><span>
        </span><span class="p_word">if</span> <span class="p_identifier">pointer</span> <span class="p_operator">==</span> <span class="p_operator">-</span><span class="p_number">1</span><span class="p_operator">:</span><span>
          </span><span class="p_identifier">pointer</span> <span class="p_operator">=</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">filedata</span><span class="p_operator">)</span><span>
        </span><span class="p_word">else</span><span class="p_operator">:</span><span>
          </span><span class="p_identifier">pointer</span> <span class="p_operator">=</span> <span class="p_identifier">pointer</span> <span class="p_operator">+</span> <span class="p_number">1</span><span>
          </span><span class="p_identifier">hits</span> <span class="p_operator">=</span> <span class="p_identifier">hits</span> <span class="p_operator">+</span> <span class="p_number">1</span><span>
      </span><span class="p_identifier">score</span> <span class="p_operator">=</span> <span class="p_identifier">score</span> <span class="p_operator">+</span> <span class="p_identifier">hits</span><span>
      </span><span class="p_word">if</span> <span class="p_identifier">maxscore</span> <span class="p_operator">&lt;</span> <span class="p_identifier">hits</span><span class="p_operator">:</span><span>
        </span><span class="p_identifier">maxscore</span> <span class="p_operator">=</span> <span class="p_identifier">hits</span><span>
        </span><span class="p_identifier">verb</span> <span class="p_operator">=</span> <span class="p_identifier">filename</span><span>
      </span><span class="p_word">if</span> <span class="p_identifier">minscore</span> <span class="p_operator">==</span> <span class="p_operator">-</span><span class="p_number">1</span> <span class="p_word">or</span> <span class="p_identifier">minscore</span> <span class="p_operator">&gt;</span> <span class="p_identifier">hits</span><span class="p_operator">:</span><span>
        </span><span class="p_identifier">minscore</span> <span class="p_operator">=</span> <span class="p_identifier">hits</span><span>
    </span><span class="p_word">else</span><span class="p_operator">:</span><span>
      </span><span class="p_commentline"># no ambiguity possible in this file at this chunksize </span><span>
      </span><span class="p_identifier">minscore</span> <span class="p_operator">=</span> <span class="p_number">0</span><span class="p_operator">;</span><span>
  </span><span class="p_identifier">score</span> <span class="p_operator">=</span> <span class="p_identifier">score</span> <span class="p_operator">/</span> <span class="p_number">1000.0</span><span>
  </span><span class="p_word">print</span> <span class="p_string">"%d\t%f\t%d\t%s"</span> <span class="p_operator">%</span> <span class="p_operator">(</span><span class="p_identifier">chunksize</span><span class="p_operator">,</span> <span class="p_identifier">score</span><span class="p_operator">,</span> <span class="p_identifier">maxscore</span><span class="p_operator">,</span> <span class="p_identifier">verb</span><span class="p_operator">)</span><span>

</span><span class="p_word">print</span> <span class="p_character">'Done.'</span></pre>
<button onclick="hide('code1', 'b')">Hide Code</button>
</div>
</fieldset>

<p>Based on the above, it would appear that not only is there no 
universally ideal context length, but there isn't even an ideal context 
length for each type of text.  Therefore the context length must be 
tailored to each edit block.  A good algorithm might be to start no 
context on either side, then increase both sides by four characters as 
many times as required until the block is unique to the particular file,
 and finish by adding another four characters to each side.  Thus the 
minimum amount of context would be a total of eight, and the maximum 
would be the length of the file (assuming a file composed entirely of a 
single repeated character).</p>

<h2>Levenshtein Distance</h2>

<p>Instead of progressively truncating the context strings and seeking 
the nearest match (as GNU's patch does), it would be more forgiving and 
more accurate to look for the overall similarities between the entire 
set of strings (prefix context, deletions and suffix context) and the 
available base document.  One simple measure of similarity between two 
texts is the <a href="http://www.nist.gov/dads/HTML/Levenshtein.html">Levenshtein distance</a>;
 the number of insertions, deletions and substitutions required to turn 
one text into another.  The smaller this number, the better the match.</p>

<p>Much research has been done on algorithms which can calculate 
Levenshtein distances.  One of the most efficient is the Bitap algorithm
 described in S. Wu and U. Manber's 1991 paper: <a href="https://neil.fraser.name/writing/patch/bitap.ps">Fast Text Searching With Errors</a>.
  This algorithm searches for exact matches between a text and a 
pattern, then it searches for matches with one error, then with two 
errors, and so on.</p>

<h2>Apples and Oranges</h2>

<p>Several potential matches may be available as a result of the 
Levenshtein analysis.  Some may be exact, others may be filled with 
errors.  Some may be close to the expected area, others may be far away.
  These two dimensions of accuracy cause problems when trying to compare
 and select the best match.  A formula is required to compute an overall
 score for each match based on the errors and the distance.</p>

<p>The exact formula is important to the behaviour of the patch 
algorithm, but it is not important to its operation.  The following 
formula is proposed as a starting point for computing a score for each 
match:</p>

<code>s = (e / p) / c + (d / t) / (1 - c)<br>
<br>
s -- overall score<br>
e -- number of errors (the Levenshtein Distance)<br>
p -- the length of the pattern<br>
d -- the distance (in characters) that the match is offset from the expected location<br>
t -- the length of the text<br>
c -- multiplier to change the relative weighting of accuracy vs. distance (a constant)</code>

<p><img src="Neil%20Fraser%20%20Writing%20%20Fuzzy%20Patch_files/apple-orange.jpg" onmouseover="this.src='apple-orange.gif'" onmouseout="this.src='apple-orange.jpg'" style="cursor: wait" align="right">
In broad strokes this formula simply adds the number of errors in the 
match to the distance which the match has been shifted.  The lower the 
result, the better the match.  The constant 'c' determines whether to 
favour poor matches near the expected location as opposed to more 
accurate matches further afield.  This allows the performance of patch 
to be tuned if it is performing poorly.  Another variable which may be 
tuned is 't' which may be coerced to a predefined minimum for small 
files (where a distance of a few characters might otherwise represent a 
significant percentage of the file length) or coerced to a predefined 
maximum for large files (where a small percentage distance might 
otherwise represent an unreasonable distance).  Evaluating the distance 
requires examining it from both a percentage and from an absolute 
perspective.</p>

<p>The tradeoff of favouring match location versus the match errors can 
be visualised using a four dimensional graph.  The width and depth 
represent the two dimensions of accuracy, each within a range of [0..1].
  The height represents the computed score, also within a range of 
[0..1].  As 'c' traverses between 0 and 1, the score for any given match
 becomes less influenced by one form of accuracy and more influenced by 
the other.  Hover the mouse over the graph to the right to see this 
traversal.</p>

<p>Implementing this formula as a separate function allows the behaviour
 of patch to be tweaked and adjusted from one location.  This function 
can control not only matching, but also cut-off points for stopping or 
restricting the matching algorithm.  This separation works as long as 
the return score is deterministic and there is never a <i>reverse</i> correlation between score and distance or errors.</p>

<h2>Inverse Pyramid</h2>

<p>A simplistic matching algorithm would scan the whole text for the 
exact pattern, then scan for one error, then two, and so on until the 
number of errors equals one less than the length of the pattern.  This 
results in a rectangular grid containing possible matches.  The scores 
for each match may be computed, and the best one returned.</p>

<pre>  <b>'Twas brillig, and the slithy toves¶Did gyre and gimble in the wabe.</b>
<b>0</b> 0000000000000000000<font color="red">1</font>000000000000000000000000000000000000000<font color="red">1</font>00000000
<b>1</b> 000000000000000000<font color="red">111</font>00000<font color="red">1</font>0000000000000000000000000000000<font color="red">111</font>0000000
<b>2</b> 00000000000000000<font color="red">11111</font>000<font color="red">111</font>00<font color="red">1111</font>0000000<font color="red">111</font>00000000<font color="red">111</font>00<font color="red">11111</font>00<font color="red">111</font>0
<b>3</b> <font color="red">11111111111111111111111111111111111111111111111111111111111111111111</font></pre>

<p>In the above example the given string is being searched for the 
pattern "the".  There are two matches with zero errors, seven matches 
with one error and twenty-six matches with two errors.  Everything is a 
match at three errors (the length of the pattern), so there is no 
benefit to calculating this or subsequent lines.  As a side note, the 
Bitap algorithm in this and subsequent examples is processed from right 
to left, so that the '1' signifying a match occurs at the start of the 
match.</p>

<p>This rectangular grid is inefficient if an an expected location is 
known.  As the number of errors increases, the area diminishes in which a
 match can reside with a higher score than the best one found to date.  
In the example below, "was" is being sought near character 25.</p>

<pre>  <b>'Twas brillig, and the slithy toves¶Did gyre and gimble in the wabe.</b>
<b>0</b> --<font color="red">1</font>00000000000000000000000000000000000000000000000000000000000------
<b>1</b> --------------00000000000000000000000000----------------------------
<b>2</b> -------------------------0000---------------------------------------</pre>

<p>The termination points for each line can be calculated by solving the
 distance in the score formula for a given error level and a given 
score.  However, if the score formula is a stand-alone function (where 
it may easily be adjusted), it may be easier to run a binary search for 
each termination point.  Furthermore, when a match is found while 
scanning a line and the location is after the expected location, then no
 further scanning on that line is required since the score of further 
matches would always be lower.  Alternately, when a match is found while
 scanning a line and the location is before the expected location, then 
the termination point can be advanced to the current distance mirrored 
on the other side of the expected location.</p>

<h2>Locations</h2>

<p>The match algorithm will locate the approximate start of the match 
(of if processed from left to right, the end of the match).  By adding 
(or subtracting) the length of the pattern, the approximate start (or 
end) of the match can also be found.  Unfortunately unless the match 
itself was exact, neither of these end points is likely to be exact.  
Furthermore, internal reference points are likely to be inexact as well.
  For example, consider this case where Alice changes a single word in 
her document and transmits a patch for Bob to apply to his version of 
the document.

</p><pre>Alice's side:
  V1:   The computer's old processor chip.
  V2:   The computer's new processor chip.
  Diff: puter's <del>old</del><ins>new</ins> process [starting near character 8]

Bob's side:
  Pattern: puter's old process [starting near character 8]
  V1:      The server's odd coprocessor chip.
  Match:   --------<font color="red">1</font>0000000000000000000000000 [error level 6]
  Subject: er's odd coprocesso</pre>

<p>Knowing the approximate start and end of the pattern allows the 
extraction of a subject string with which to work on.  A prerequisite to
 making any insertions or deletions is the discovery of a translation 
matrix between indices in the pattern string and the subject string.  
One approach is to perform multiple Bitap matches between one string and
 all substrings of the other string.  A less expensive approach is to 
diff the two strings:</p>

<pre>Pattern: puter's old process
Subject: er's odd coprocesso
Diff:    <del>put</del>er's o<del>l</del><ins>d</ins>d <ins>co</ins>process<ins>o</ins></pre>

<p><a href="https://neil.fraser.name/writing/diff/">Diff algorithms</a> 
can be complex but very accurate and efficient.  For this application 
there is no need to invoke the line-based speedup, and it is important 
not to use any post-processing cleanup algorithms since one wants as 
much detail as possible.  This diff allows indices from one string to be
 converted into indices on the other string.</p>

<fieldset><legend>Sample Code</legend>
<div id="code2"><button onclick="show('code2', 'a')">Show JavaScript</button> &nbsp; <button onclick="show('code2', 'b')">Show Python</button></div>
<div id="code2a" style="display: none">
<pre><span class="oper">function</span> <span class="func">diff_xindex</span>(<span class="var">diff</span>, <span class="var">loc</span>) {
  <span class="comment">// diff is a set of differences between text1 and text2.</span>
  <span class="comment">// loc is a location in text1, compute and return the equivalent location in text2.</span>
  <span class="comment">// e.g. "The cat" vs "The big cat", 1-&gt;1, 5-&gt;8</span>
  <span class="oper">var</span> <span class="var">chars1</span> <span class="oper">=</span> <span class="num">0</span>;
  <span class="oper">var</span> <span class="var">chars2</span> <span class="oper">=</span> <span class="num">0</span>;
  <span class="oper">var</span> <span class="var">last_chars1</span> <span class="oper">=</span> <span class="num">0</span>;
  <span class="oper">var</span> <span class="var">last_chars2</span> <span class="oper">=</span> <span class="num">0</span>;
  <span class="oper">for</span> (<span class="oper">var</span> <span class="var">x</span><span class="oper">=</span><span class="num">0</span>; <span class="var">x</span><span class="oper">&lt;</span><span class="var">diff</span>.<span class="var">length</span>; <span class="var">x</span><span class="oper">++</span>) {
    <span class="oper">if</span> (<span class="var">diff</span>[<span class="var">x</span>][<span class="num">0</span>] <span class="oper">!=</span> <span class="num">1</span>) <span class="comment">// Equality or deletion.</span>
      <span class="var">chars1</span> <span class="oper">+=</span> <span class="var">diff</span>[<span class="var">x</span>][<span class="num">1</span>].<span class="var">length</span>;
    <span class="oper">if</span> (<span class="var">diff</span>[<span class="var">x</span>][<span class="num">0</span>] <span class="oper">!=</span> <span class="num">-1</span>) <span class="comment">// Equality or insertion.</span>
      <span class="var">chars2</span> <span class="oper">+=</span> <span class="var">diff</span>[<span class="var">x</span>][<span class="num">1</span>].<span class="var">length</span>;
    <span class="oper">if</span> (<span class="var">chars1</span> <span class="oper">&gt;</span> <span class="var">loc</span>) <span class="comment">// Overshot the location.</span>
      <span class="oper">break</span>
    <span class="var">last_chars1</span> <span class="oper">=</span> <span class="var">chars1</span>;
    <span class="var">last_chars2</span> <span class="oper">=</span> <span class="var">chars2</span>;
  }
  <span class="oper">if</span> (<span class="var">diff</span>.<span class="var">length</span> <span class="oper">!=</span> <span class="var">x</span> <span class="oper">&amp;&amp;</span> <span class="var">diff</span>[<span class="var">x</span>][<span class="num">0</span>] <span class="oper">==</span> <span class="num">-1</span>) <span class="comment">// The location was deleted.</span>
    <span class="oper">return</span> <span class="var">last_chars2</span>;
  <span class="comment">// Add the remaining character length.</span>
  <span class="oper">return</span> <span class="var">last_chars2</span> <span class="oper">+</span> (<span class="var">loc</span> <span class="oper">-</span> <span class="var">last_chars1</span>);
}</pre>
<p>In this <!--and subsequent examples-->example, the internal format 
for representing a set of differences is an array of tuples.  The first 
element of each tuple specifies if it is an <ins>insertion</ins> (1), a <del>deletion</del> (-1) or an equality (0).  The second element specifies the affected text.</p>

<button onclick="hide('code2', 'a')">Hide JavaScript</button> &nbsp; <button disabled="disabled">Show Python</button>
</div>
<div id="code2b" style="display: none">
<pre><span class="p_word">def</span> <span class="p_defname">diff_xindex</span><span class="p_operator">(</span><span class="p_identifier">diff</span><span class="p_operator">,</span> <span class="p_identifier">loc</span><span class="p_operator">):</span><span>
  </span><span class="p_commentline"># loc is a location in text1, compute and return the equivalent location in text2.</span><span>
  </span><span class="p_commentline"># e.g. "The cat" vs "The big cat", 1-&gt;1, 5-&gt;8</span><span>
  </span><span class="p_identifier">chars1</span> <span class="p_operator">=</span> <span class="p_number">0</span><span>
  </span><span class="p_identifier">chars2</span> <span class="p_operator">=</span> <span class="p_number">0</span><span>
  </span><span class="p_identifier">last_chars1</span> <span class="p_operator">=</span> <span class="p_number">0</span><span>
  </span><span class="p_identifier">last_chars2</span> <span class="p_operator">=</span> <span class="p_number">0</span><span>
  </span><span class="p_word">for</span> <span class="p_identifier">x</span> <span class="p_word">in</span> <span class="p_identifier">range</span><span class="p_operator">(</span><span class="p_number">0</span><span class="p_operator">,</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">diff</span><span class="p_operator">)):</span><span>
    </span><span class="p_operator">(</span><span class="p_identifier">op</span><span class="p_operator">,</span> <span class="p_identifier">txt</span><span class="p_operator">)</span> <span class="p_operator">=</span> <span class="p_identifier">diff</span><span class="p_operator">[</span><span class="p_identifier">x</span><span class="p_operator">]</span><span>
    </span><span class="p_word">if</span> <span class="p_identifier">op</span> <span class="p_operator">!=</span> <span class="p_number">1</span><span class="p_operator">:</span> <span class="p_commentline"># Equality or deletion.</span><span>
      </span><span class="p_identifier">chars1</span> <span class="p_operator">+=</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">txt</span><span class="p_operator">)</span><span>
    </span><span class="p_word">if</span> <span class="p_identifier">op</span> <span class="p_operator">!=</span> <span class="p_operator">-</span><span class="p_number">1</span><span class="p_operator">:</span> <span class="p_commentline"># Equality or insertion.</span><span>
      </span><span class="p_identifier">chars2</span> <span class="p_operator">+=</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">txt</span><span class="p_operator">)</span><span>
    </span><span class="p_word">if</span> <span class="p_identifier">chars1</span> <span class="p_operator">&gt;</span> <span class="p_identifier">loc</span><span class="p_operator">:</span> <span class="p_commentline"># Overshot the location.</span><span>
      </span><span class="p_word">break</span><span>
    </span><span class="p_identifier">last_chars1</span> <span class="p_operator">=</span> <span class="p_identifier">chars1</span><span>
    </span><span class="p_identifier">last_chars2</span> <span class="p_operator">=</span> <span class="p_identifier">chars2</span><span>
  
  </span><span class="p_word">if</span> <span class="p_identifier">len</span><span class="p_operator">(</span><span class="p_identifier">diff</span><span class="p_operator">)</span> <span class="p_operator">!=</span> <span class="p_identifier">x</span> <span class="p_word">and</span> <span class="p_identifier">diff</span><span class="p_operator">[</span><span class="p_identifier">x</span><span class="p_operator">][</span><span class="p_number">0</span><span class="p_operator">]</span> <span class="p_operator">==</span> <span class="p_operator">-</span><span class="p_number">1</span><span class="p_operator">:</span> <span class="p_commentline"># The location was deleted.</span><span>
    </span><span class="p_word">return</span> <span class="p_identifier">last_chars2</span><span>
  </span><span class="p_commentline"># Add the remaining len(character).</span><span>
  </span><span class="p_word">return</span> <span class="p_identifier">last_chars2</span> <span class="p_operator">+</span> <span class="p_operator">(</span><span class="p_identifier">loc</span> <span class="p_operator">-</span> <span class="p_identifier">last_chars1</span><span class="p_operator">)</span></pre>
<p>In this <!--and subsequent examples-->example, the internal format 
for representing a set of differences is an array of tuples.  The first 
element of each tuple specifies if it is an <ins>insertion</ins> (1), a <del>deletion</del> (-1) or an equality (0).  The second element specifies the affected text.</p>

<button disabled="disabled">Show JavaScript</button> &nbsp; <button onclick="hide('code2', 'b')">Hide Python</button>
</div>
</fieldset>

<p>Thus it becomes straightforward to delete "odd" and insert "new" it its place:</p>

<pre>Bob's V2: The server's new coprocessor chip.</pre>

<p>The final step is to note the difference between the expected 
location (8) and the found location (9).  The next patch (if there is 
one) should have its expected location adjusted by the difference (+1).</p>

<h2>Bite-sized Patches</h2>

<p>The Bitap algorithm for fuzzy matching gains its speed by exploiting 
the computer's dexterity with bitwise operators.  Unfortunately this 
technique fails when the number of characters in the pattern exceeds the
 number of bits in the register.  This limit is typically 32.  Since 
patches can come in larger sizes, they need to be broken up into smaller
 pieces.  The most common situation is a large deletion:</p>

<pre>@@ -1,45 +1,8 @@
 The 
<span class="del">-quick brown fox jumped over the lazy </span>
 dog.</pre>

<p>Splitting a patch requires creating relevant context on each side of 
the new patches.  Failure to provide some contextual padding at each end
 of a patch may result in dropped or extra characters due to an 
inability of the fuzzy matching to find the exact end points.</p>

<pre>@@ -1,32 +1,8 @@
 The 
<span class="del">-quick brown fox jumped o</span>
 ver 
@@ -1,21 +1,8 @@
 The 
<span class="del">-ver the lazy </span>
 dog.</pre>

<p>The overlapping context strings of each patch necessarily specifies 
an order in which the patches must be applied.  The context from one 
patch may be altered or deleted by another; in the above example "ver" 
is used as context by the first patch and deleted by the second patch.  
This contrasts with GNU's patch where each patch is separate from the 
others and may be installed in any order.</p>

<div><img style="width: 100%" src="Neil%20Fraser%20%20Writing%20%20Fuzzy%20Patch_files/lineblue.jpg" alt="-------------------------------------" width="540" height="4"></div>

<p><i>See an <a href="https://github.com/google/diff-match-patch">implementation</a> and online <a href="https://neil.fraser.name/software/diff_match_patch/demos/patch.html">demonstration</a> of patch.<br>
See also the companion paper on patch's counterpart: <a href="https://neil.fraser.name/writing/diff/">Diff</a></i></p>

<div class="nav"><a href="https://neil.fraser.name/">Neil Fraser</a>: <a href="https://neil.fraser.name/writing/">Writing</a>: Fuzzy Patch</div>
<div class="lmb">Last modified: 8 June 2006</div>



</body></html>